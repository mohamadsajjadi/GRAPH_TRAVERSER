# پوریا خواجه‌پور ۴۰۰۱۷۱۳۹۲ - سید محمد سجادیان ۹۸۱۷۰۸۶۲ 

# بخش اول - الگوی adapter
## زیربخش ۱ - انتخاب نوع adapter
ما در کد خود از روش Object Scope استفاده کردیم. ویژگی‌های مهم این روش و برتری‌های آن نسبت به روش Class Scope این است که میتوان نمونه‌ای از کلاس خارجی را در آداپتور نگه داشت و خدماتی که در کد استفاده شده‌اند از طریق توابع مربوطه در اختیار Client قرار داد. این موضوع باعث حفظ انتزاع و کپسوله‌کردن می‌شود و اطمینان حاصل میکند که از تابع ناخواسته‌ای استفاده نمیشود. در مقابل آن دلیل عدم استفاده از Class Scope آن است که این روش مبتنی بر ارث‌بری آداپتور از کتابخانه خارجی است و باعث میشود که اولا کلیه‌ی توابع آن در دسترس کلاینت باشد و ازطرفی انتزاع را برهم‌میریزد و پیچیدگی ایجاد و نگهداری کد را افزایش میدهد چرا که هربار کتاب‌خانه خارجی را تغییر میدهیم مجبور میشویم کل این کلاس را از اول مینویسیم و حتی ممکن است کل تست‌های ما را هم بی‌فایده کند و مجبور شویم یک Test Suite جدید برای این کلاس بنویسیم. همچنین برای آن که تغییر کتابخانه تنها منجر به تغییر آداپتور شود هم روش دوم مناسب نیست چون توابع مورد استفاده آن هم هربار تغییر میکنند.
## زیربخش ۲ - نحوه پیاده‌سازی pattern
1. **تعریف رابط `GraphInterface<V>`**: در این رابط توابع addVertex و addEdge و getNeighbours را قرار دادیم. استفاده از رابط بجای ساخت مستقیم رابط باعث میشود تا بتوانیم پیاده‌سازی‌های مختلف داشته باشیم که در شرایط مختلف بتوانند استفاده شوند.

2. **پیاده‌سازی کلاس `GraphAdapter`**: این کلاس رابط `GraphInterface<V>` را پیاده‌سازی می‌کند و به طور داخلی از یک نمونه از `SparseMultigraph` از کتابخانه `edu.uci.ics.jung.graph` استفاده می‌کند. متدهای موجود در رابط با فراخوانی متدهای مربوطه `SparseMultigraph` پیاده‌سازی می‌شوند.

3. **کد `Main` و `DfsGraphTraverser` و `BfsGraphTraverser`**: این کلاس‌ها طریقه‌ی استفاده سایر کلاس‌ها از آداپتور ما را نشان میدهند.

# بخش دوم - library change
## زیربخش ۱
برای تغییر کتابخانه تنها کلاس آداپتور تغییر کرد که این تغییرات شامل استفاده از موجودیت `SimpleDirectedGraph` کتابخانه `JGraphT` بجای `SparseMultigraph` کتابخانه `jung` و همچنین اعمال تغییراتی در منطق کد توابع میشود.

## زیربخش ۲
بجز کلاس آداپتور کلاس دیگری در اثر این تغییر کتابخانه تغییری نکرد.

# بخش سوم - تحلیل strategy pattern
## سوال ۱ - استفاده از این الگو به چه علت قابل قبول است؟
الگوی استراتژی به این دلیل قابل قبول است که امکان پیاده‌سازی و استفاده از روش‌های متنوع پیمایش گراف را از طریق یک رابط واحد (`Traverser`) برای ما مهیا میکند. در صورتی که در آینده بخواهیم روش پیمایش جدیدی به برنامه‌ی خود اضافه کنیم کافیست این رابط را پیاده‌سازی کنیم.
کد این رابط:
```java
public interface Traverser {
    List<Integer> traverse(Integer startVertex);
}
```
## سوال ۲ - روش تحقق این الگو را به صورت مختصر و در حد ۳ سطر توضیح دهید.

1. در پیاده‌سازی، یک رابط بنام Traverser تعریف شده است که متدهای عمومی برای پیمایش گراف را مشخص می‌کند.
2. سپس، برای هر روش پیمایش (مانند BFS و DFS)، یک کلاس پیاده‌سازی جداگانه ایجاد شده که رابط Traverser و تابع traverse را پیاده‌سازی می‌کند.
3. در نهایت، کلاس‌های دیگر مانند Main از طریق رابط Traverser یک الگوریتم پیمایش را در زمان اجرا (Runtime) انتخاب و استفاده می‌کنند.
